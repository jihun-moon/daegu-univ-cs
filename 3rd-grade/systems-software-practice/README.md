
# 💻 시스템소프트웨어실무 (Systems Software Practice)

**[과목 정보]**

  - **수강:** 3학년 1학기
  - **핵심 기술:** `C`, `Assembly`
  - **핵심 역량:** `컴파일 과정 이해`, `시스템 콜 활용`, `저수준 프로그래밍`

-----

### 📖 과목 개요 (Overview)

**운영체제(OS)와 하드웨어 사이에서 동작**하며 응용 소프트웨어의 실행을 돕는 시스템 소프트웨어의 원리를 깊이 있게 탐구한 과목입니다. 컴파일러, 어셈블러, 링커, 로더가 소스 코드를 실행 파일로 만들고 메모리에 적재하는 전체 과정을 **저수준(low-level) 관점에서 학습**했습니다. 이를 통해 프로그램 성능을 최적화하고 운영체제의 동작을 이해하는 시스템 레벨 개발 역량을 갖추게 되었습니다.

### 🚀 핵심 프로젝트: 나만의 쉘(Shell) 구현

  - **프로젝트 목표:** 리눅스의 기본 쉘 기능을 C언어로 직접 구현하여 프로세스 생성 및 제어, 시스템 콜의 동작 원리를 체득합니다.
  - **주요 기능:**
      - 기본 명령어 (`ls`, `cd`, `pwd` 등) 처리
      - 파이프(`|`)를 이용한 프로세스 간 통신
      - 리다이렉션(`>`)을 이용한 출력 재지정

### 🛠️ 개발 프로세스 및 핵심 기술

1.  **프로세스 생성:** 사용자가 명령어를 입력하면 `fork()` 시스템 콜을 호출하여 자식 프로세스를 생성했습니다.
2.  **명령어 실행:** 자식 프로세스는 `exec()` 계열 함수를 사용하여 사용자가 입력한 명령어를 새로운 프로그램으로 교체하여 실행했습니다.
3.  **프로세스 동기화:** 부모 프로세스는 `wait()` 시스템 콜을 사용하여 자식 프로세스가 종료될 때까지 대기하며, 이를 통해 쉘의 안정적인 명령어 처리를 구현했습니다.
4.  **파이프 및 리다이렉션:** `pipe()`와 `dup2()` 시스템 콜을 활용하여 프로세스 간 표준 입출력 흐름을 제어하고, 명령어의 결과를 파일로 저장하거나 다른 명령어의 입력으로 전달하는 기능을 구현했습니다.

### 🌱 성장 및 핵심 경험 (Growth & Takeaways)

  - `fork()`, `exec()`, `wait()` 등 핵심 시스템 콜을 통해 **프로세스가 생성되고 소멸하는 생명주기**를 완벽하게 이해하게 되었습니다.
  - 운영체제가 응용 프로그램을 어떻게 관리하고 상호작용하는지에 대한 원리를 코드로 직접 구현하며 체득했습니다.
  - 저수준 시스템 프로그래밍 경험을 통해 **메모리 및 자원 관리의 중요성**을 깨닫고, 효율적인 코드를 작성하는 능력을 함양했습니다.

### 📸 프로젝트 개념도

| 프로세스 생성 (fork) | 명령어 실행 (exec) | 파이프라인 구현 (pipe) |
|:---:|:---:|:---:|
|  |  |  |
| *`fork()`로 부모-자식 프로세스 복제* | *`exec()`로 자식 프로세스 교체* | *`pipe()`로 프로세스 간 데이터 전달* |

-----

## 2\. 리눅스 명령어 및 BASH 쉘 프로그래밍

**[기술 스택]**

  - **환경:** `Linux (Bash Shell)`
  - **핵심 역량:** `CLI 활용`, `쉘 스크립트 작성`, `자동화`

-----

### 📖 학습 개요 (Overview)

리눅스 환경에서의 기본적인 파일 시스템 조작부터, **Bash 쉘 스크립트**를 활용한 조건문, 반복문, 함수 프로그래밍까지 학습했습니다. 이를 통해 반복적인 작업을 자동화하고 서버 관리 효율성을 극대화하는 능력을 길렀습니다.

### 📝 기본 리눅스 명령어 요약

| 분류 | 명령어 | 설명 |
| :--- | :--- | :--- |
| **파일/디렉토리** | `ls`, `cd`, `pwd`, `rm`, `cp`, `mv` | 목록 확인, 이동, 경로 출력, 삭제, 복사, 이동/이름변경 |
| **파일 내용 확인** | `cat`, `head`, `tail`, `more`, `less` | 전체 출력, 앞/뒤 일부 출력, 페이지 단위 보기 |
| **파일 정보** | `file` | 파일의 종류 (텍스트, 실행 파일 등) 확인 |
| **화면 제어** | `clear` | 터미널 화면 정리 |

### 📜 BASH 쉘 프로그래밍 핵심 문법

1.  **Shebang (`#!`)**: 스크립트를 실행할 인터프리터를 지정합니다. (`#!/bin/bash`)
2.  **변수 및 사용자 입력**:
      - 변수 선언: `name="World"`
      - 사용자 입력: `read -p "Enter your name: " name`
      - 특수 변수: `$0` (스크립트 이름), `$1` (첫 번째 인자), `$#` (인자 개수), `$?` (종료 코드)
3.  **조건문**:
      - `if [ "$var" -eq "value" ]; then ... elif ... else ... fi`
      - `case "$var" in pattern1) ... ;; *) ... ;; esac`
4.  **반복문**:
      - `for i in {1..5}; do ... done`
      - `while [ "$cond" = true ]; do ... done`
      - `until [ "$cond" = true ]; do ... done`
5.  **함수**:
      - `function_name() { echo "Hello, $1"; }`
      - `local` 키워드로 지역 변수 선언 가능

### 🖥️ 쉘 스크립트 예제: 간단한 백업 스크립트

```bash
#!/bin/bash

# 백업할 디렉토리와 저장할 위치 지정
SOURCE_DIR="/home/user/data"
BACKUP_DIR="/var/backups"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BACKUP_FILE="$BACKUP_DIR/backup-$TIMESTAMP.tar.gz"

# 백업 디렉토리가 없으면 생성
if [ ! -d "$BACKUP_DIR" ]; then
    mkdir -p "$BACKUP_DIR"
fi

# tar 명령어로 압축하여 백업 실행
tar -czf "$BACKUP_FILE" "$SOURCE_DIR"

# 결과 출력
if [ $? -eq 0 ]; then
    echo "Backup successful: $BACKUP_FILE"
else
    echo "Backup failed."
fi
```

-----

## 3\. 가상화 기술 및 Docker

**[기술 스택]**

  - **핵심 기술:** `Virtualization`, `Hypervisor`, `Docker`, `Docker Compose`
  - **핵심 역량:** `컨테이너 기반 배포`, `마이크로서비스 아키텍처 이해`, `인프라 관리`

-----

### 📖 학습 개요 (Overview)

물리적 하드웨어를 논리적으로 분할하여 사용하는 **가상화 기술의 원리**부터, 현대적인 애플리케이션 배포 표준으로 자리 잡은 **Docker 컨테이너 기술**까지 학습했습니다. 가상 머신(VM)과 컨테이너의 차이점을 이해하고, Docker를 활용하여 애플리케이션을 신속하고 일관성 있게 배포하는 방법을 익혔습니다.

### 🛠️ 핵심 개념 정리

1.  **가상화 (Virtualization)**:

      - **하이퍼바이저 (Hypervisor)**: 가상 머신을 생성하고 구동하는 소프트웨어.
          - **Type 1 (Bare-metal):** 하드웨어에 직접 설치 (예: KVM, VMware ESXi). 성능이 우수.
          - **Type 2 (Hosted):** 호스트 OS 위에서 실행 (예: VirtualBox). 설치가 간편.
      - **전가상화 vs 반가상화**: 게스트 OS의 수정 여부에 따른 기술 분류. 현대에는 CPU의 하드웨어 가상화 지원(VT-x, AMD-V)을 활용하는 것이 일반적.

2.  **컨테이너 (Container)**:

      - **원리**: 호스트 OS의 커널을 공유하며, \*\*네임스페이스(Namespace)\*\*로 리소스를 격리하고 **Cgroups**로 사용량을 제어.
      - **장점**: VM보다 훨씬 가볍고, 시작 속도가 빠르며, 이식성이 매우 높음. "내 컴퓨터에선 되는데..." 문제를 해결.

### 🐳 Docker 활용 프로세스

1.  **Dockerfile 작성**: 애플리케이션 실행 환경을 코드로 정의합니다. (베이스 이미지, 의존성 설치, 소스코드 복사 등)
2.  **이미지 빌드**: `docker build` 명령어로 Dockerfile을 실행하여 재사용 가능한 **Docker 이미지**를 생성합니다.
3.  **컨테이너 실행**: `docker run` 명령어로 이미지를 실행하여 격리된 **Docker 컨테이너**를 생성합니다.
4.  **다중 컨테이너 관리 (Docker Compose)**: `docker-compose.yml` 파일에 여러 서비스(컨테이너)의 관계와 설정을 정의하고, `docker-compose up` 명령어로 한 번에 관리합니다.

### 📈 Docker 도입 효과 및 경험

  - **개발-운영 환경 일치**: Docker를 통해 개발, 테스트, 운영 환경을 동일하게 구성하여 배포 시 발생할 수 있는 오류를 원천적으로 차단했습니다.
  - **신속한 배포 및 확장**: 애플리케이션과 실행 환경을 이미지 하나로 패키징하여, 어떤 서버에서든 몇 초 만에 배포하고 필요에 따라 확장하는 경험을 했습니다.
  - **마이크로서비스 아키텍처(MSA) 이해**: 각 기능이 독립적인 컨테이너로 분리되어 동작하는 MSA의 기반 기술을 이해하고, 서비스 간 통신 및 데이터 관리 방법을 학습했습니다.

### 📸 기술 비교 시각화

| 가상 머신 (VM) 구조 | 컨테이너 구조 | Docker Compose 아키텍처 예시 |
|:---:|:---:|:---:|
|  |  |  |
| *각 VM이 독립적인 OS를 가짐* | *호스트 OS의 커널을 공유* | *Web, DB, Cache 서비스를 함께 관리* |
